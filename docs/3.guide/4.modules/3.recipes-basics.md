---
title: "添加插件、组件及更多内容"
description: "了解如何从您的模块中注入插件、组件、组合函数和服务器路由。"
---

以下是模块作者常用的一些模式。

## 修改 Nuxt 配置

模块可以读取并修改 Nuxt 配置。以下是一个启用实验性功能的模块示例。

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 如果还不存在，我们创建 `experimental` 对象
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  },
})
```

当需要处理更复杂的配置修改时，你应该考虑使用 [defu](https://github.com/unjs/defu)。

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt" target="_blank"}
观看 Vue School 视频，了解如何修改 Nuxt 配置。
::

## 向运行时公开选项

由于模块不是应用的运行时部分，所以它们的选项也不在运行时中。不过，在很多情况下，你可能需要在运行时代码中访问这些模块选项。我们推荐通过 Nuxt 的 [`runtimeConfig`](/docs/4.x/api/nuxt-config#runtimeconfig) 来公开所需的配置。

<!-- TODO: 在 #18466（或等价功能）之后更新 -->

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo,
    })
  },
})
```

注意，我们使用 [`defu`](https://github.com/unjs/defu) 来扩展用户提供的公共运行时配置，而非直接覆盖。

然后，你可以在插件、组件或应用中像访问其他运行时配置一样访问模块选项：

```js
import { useRuntimeConfig } from '@nuxt/kit'

const options = useRuntimeConfig().public.myModule
```

::warning
请注意不要在公共运行时配置中暴露任何敏感的模块配置，比如私有 API 密钥，因为它们会最终包含在公共包中。
::

:read-more{to="/docs/4.x/guide/going-further/runtime-config"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt" target="_blank"}
观看 Vue School 视频，了解如何传递和公开 Nuxt 模块选项。
::

## 添加插件

插件是模块添加运行时逻辑的常用方式。你可以使用 `addPlugin` 工具从模块中注册它们。

```js
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 创建解析器以解析相对路径
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  },
})
```

:read-more{to="/docs/4.x/guide/going-further/kit"}

## 添加组件

如果你的模块需要提供 Vue 组件，你可以使用 `addComponent` 工具将它们添加为 Nuxt 的自动导入组件。

```ts twoslash
import { addComponent, createResolver, defineNuxtModule, useRuntimeConfig } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // 来自 runtime 目录
    addComponent({
      name: 'MySuperComponent', // 在 Vue 模板中使用的组件名称
      export: 'MySuperComponent', // （可选）如果组件是命名导出而非默认导出
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue'),
    })

    // 来自库
    addComponent({
      name: 'MyAwesomeComponent', // 在 Vue 模板中使用的组件名称
      export: 'MyAwesomeComponent', // （可选）如果组件是命名导出而非默认导出
      filePath: '@vue/awesome-components',
    })
  },
})
```

或者，你也可以使用 `addComponentsDir` 添加整个目录。

```ts
import { addComponentsDir, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components'),
    })
  },
})
```

::tip{icon="i-lucide-lightbulb"}
强烈建议为导出的组件添加前缀，以避免与用户代码或其他模块发生冲突。

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## 添加组合函数

如果你的模块需要提供组合函数，你可以使用 `addImports` 工具将它们添加为 Nuxt 的自动导入。

```ts
import { addImports, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // 组合函数的名称
      as: 'useMyComposable', // （可选）在消费应用中可用的别名
      from: resolver.resolve('runtime/composables/useComposable'), // 组合函数路径
    })
  },
})
```

多条目可作为数组传入：

```ts
import { addImports, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports([
      { name: 'useFirstComposable', from: resolver.resolve('runtime/composables/useFirstComposable') },
      { name: 'useSecondComposable', from: resolver.resolve('runtime/composables/useSecondComposable') },
    ])
  },
})
```

或者，你可以使用 `addImportsDir` 添加整个目录。

```ts
import { addImportsDir, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  },
})
```

::tip{icon="i-lucide-lightbulb"}
强烈建议为导出的组合函数添加前缀，以避免与用户代码或其他模块发生冲突。

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## 添加服务器路由

```ts
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/_my-module/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get'),
    })
  },
})
```

你也可以添加动态服务器路由：

```ts
import { addServerHandler, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/_my-module/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get'),
    })
  },
})
```

::tip{icon="i-lucide-lightbulb"}
强烈建议为服务器路由添加前缀，以避免与用户自定义路由冲突。像 `/api/auth`、`/api/login` 或 `/api/user` 这类常用路径可能已被应用占用。

:read-more{to="/docs/4.x/guide/modules/best-practices#prefix-your-exports"}
::

## 添加其他资源

如果你的模块需要提供其他类型的资源，也可以注入。以下是一个通过 Nuxt 的 `css` 数组注入样式表的简单示例模块。

```js
import { addPlugin, createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  },
})
```

一个更高级的示例，通过 [Nitro](/docs/4.x/guide/concepts/server-engine) 的 `publicAssets` 选项公开一整文件夹的资源：

```js
import { createResolver, defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365, // 1 年
      })
    })
  },
})
```

## 使用其他模块

如果你的模块依赖其他模块，可以使用 `moduleDependencies` 选项指定。这样可以更稳健地处理模块依赖，支持版本约束和配置合并：

```ts
import { createResolver, defineNuxtModule } from '@nuxt/kit'

const resolver = createResolver(import.meta.url)

export default defineNuxtModule<ModuleOptions>({
  meta: {
    name: 'my-module',
  },
  moduleDependencies: {
    '@nuxtjs/tailwindcss': {
      // 你可以为模块指定版本约束
      version: '>=6',
      // 任何需覆盖 `nuxt.options` 的配置
      overrides: {
        exposeConfig: true,
      },
      // 任何需设置的配置。它会覆盖模块的默认值，
      // 但不会覆盖 `nuxt.options` 中的配置
      defaults: {
        config: {
          darkMode: 'class',
          content: {
            files: [
              resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
              resolver.resolve('./runtime/*.{mjs,js,ts}'),
            ],
          },
        },
      },
    },
  },
  setup (options, nuxt) {
    // 我们可以注入包含 Tailwind 指令的 CSS 文件
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))
  },
})
```

::callout{type="info"}
`moduleDependencies` 选项取代了已废弃的 `installModule` 函数，并确保正确的安装顺序和配置合并。
::