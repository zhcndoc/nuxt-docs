---
title: 遗留 Composition API
description: '了解如何使用 Nuxt Bridge 迁移到 Composition API。'
---

Nuxt Bridge 提供对 Composition API 语法的支持。它专门设计为与 Nuxt 3 保持一致。因此，如果你之前已经在使用 Composition API，启用 Nuxt Bridge 时需要执行一些额外步骤。

## 移除模块

- 从依赖中移除 `@vue/composition-api`。
- 从依赖中移除 `@nuxtjs/composition-api`（并且从 `nuxt.config` 的 modules 中移除）。

## 使用 `@vue/composition-api`

如果你之前只使用了 `@vue/composition-api` 而没有使用 `@nuxtjs/composition-api`，那么事情非常简单。

1. 首先，移除你手动注册 Composition API 的插件。Nuxt Bridge 会为你处理此事。

   ```diff
   - import Vue from 'vue'
   - import VueCompositionApi from '@vue/composition-api'
   -
   - Vue.use(VueCompositionApi)
   ```

2. 否则，你无需做任何事情。不过，如果你愿意，可以移除从 `@vue/composition-api` 的显式导入，改由 Nuxt Bridge 为你自动导入。

## 从 `@nuxtjs/composition-api` 迁移

Nuxt Bridge 对 Composition API 的实现与 `@nuxtjs/composition-api` 略有不同，并提供了不同的 composable（旨在与 Nuxt 3 提供的 composable 保持一致）。

由于某些 composable 已被移除且尚无替代方案，这将是一个稍微复杂一些的过程。

### 从 buildModules 中移除 `@nuxtjs/composition-api/module`

你不必立即更新你的导入——Nuxt Bridge 将为你当前的大多数导入自动提供“兼容层”，以便你有时间迁移到新的、与 Nuxt 3 兼容的 composable，但有以下例外：

- `withContext` 已被移除。见 [下文](/docs/4.x/bridge/nuxt3-compatible-api#usecontext-and-withcontext)。
- `useStatic` 已被移除。当前没有替代方案。如果你对此有使用场景，请随时发起讨论。
- 已弃用的 `reqRef` 和 `reqSsrRef` 现在已完全移除。请按照下面关于 [ssrRef](/docs/4.x/bridge/nuxt3-compatible-api#ssrref-and-shallowssrref) 的说明进行替换。

### 设置 `bridge.capi`

```ts
import { defineNuxtConfig } from '@nuxt/bridge'

export default defineNuxtConfig({
  bridge: {
    capi: true,
    nitro: false, // If migration to Nitro is complete, set to true
  },
})
```

对于你从 `@nuxtjs/composition-api` 使用的每个其他 composable，请按照下面的步骤进行。

### useFetch

`$fetchState` 和 `$fetch` 已被移除。

```diff
const {
- $fetch,
- $fetchState,
+ fetch,
+ fetchState,
} = useFetch(() => { posts.value = await $fetch('/api/posts') })
```

### `defineNuxtMiddleware`

这是一个类型帮助的存根函数，现在已被移除。

移除 `defineNuxtMiddleware` 包装：

```diff
- import { defineNuxtMiddleware } from '@nuxtjs/composition-api`
- export default defineNuxtMiddleware((ctx) => {})
+ export default (ctx) => {}
```

如需 TypeScript 支持，你可以使用 `@nuxt/types`：

```ts
import type { Middleware } from '@nuxt/types'

export default <Middleware> function (ctx) { }
```

### `defineNuxtPlugin`

这是一个类型帮助的存根函数，现在已被移除。

你也可以继续使用 Nuxt 2 风格的插件，只需移除该函数（如同 [defineNuxtMiddleware](/docs/4.x/bridge/bridge-composition-api#definenuxtmiddleware)）。

移除 `defineNuxtPlugin` 包装：

```diff
- import { defineNuxtPlugin } from '@nuxtjs/composition-api'
- export default defineNuxtPlugin((ctx, inject) => {})
+ export default (ctx, inject) => {}
```

如需 TypeScript 支持，你可以使用 `@nuxt/types`：

```ts
import type { Plugin } from '@nuxt/types'

export default <Plugin> function (ctx, inject) {}
```

::warning
虽然此示例是有效的，但 Nuxt 3 引入了一个新的 defineNuxtPlugin 函数，其签名略有不同。
::

:ReadMore{link="/docs/4.x/guide/directory-structure/app/plugins#creating-plugins"}

### `useRouter` 和 `useRoute`

Nuxt Bridge 通过 [`useRouter`](/docs/4.x/api/composables/use-router) 和 `useRoute` 为这些 composable 提供了直接替代。

唯一的关键区别是 [`useRoute`](/docs/4.x/api/composables/use-route) 不再返回一个 computed 属性。

```diff
- import { useRouter, useRoute } from '@nuxtjs/composition-api'

  const router = useRouter()
  const route = useRoute()

- console.log(route.value.path)
+ console.log(route.path)
```