---
title: "模块作者指南"
description: "学习如何创建 Nuxt 模块，以集成、增强或扩展任何 Nuxt 应用。"
image: '/socials/module-author-guide.jpg'
---

Nuxt 的 [配置](/docs/api/nuxt-config) 和 [钩子](/docs/guide/going-further/hooks) 系统使得定制 Nuxt 的各个方面并添加任何你可能需要的集成（Vue 插件、CMS、服务器路由、组件、日志等）成为可能。

**Nuxt 模块** 是在使用 `nuxt dev` 启动开发模式或使用 `nuxt build` 构建生产项目时依次运行的函数。  
通过模块，你可以封装、规范测试并作为 npm 包分享自定义解决方案，而无需给项目添加不必要的样板代码，或修改 Nuxt 本身。

## 快速开始

我们推荐你使用我们的[模块起始模板](https://github.com/nuxt/starter/tree/module)开始你的 Nuxt 模块开发：

::code-group{sync="pm"}

```bash [npm]
npm create nuxt -- -t module my-module
```

```bash [yarn]
yarn create nuxt -t module my-module
```

```bash [pnpm]
pnpm create nuxt -t module my-module
```

```bash [bun]
bun create nuxt -- -t module my-module
```
::

这将创建一个名为 `my-module` 的项目，带有开发和发布模块所需的所有样板代码。

**下一步：**

1. 在你喜欢的 IDE 中打开 `my-module`
2. 使用你喜欢的包管理器安装依赖
3. 使用 `npm run dev:prepare` 准备本地开发文件
4. 按照本文档了解更多关于 Nuxt 模块的内容

### 使用起始模板

了解如何使用模块起始模板执行基础任务。

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/navigating-the-official-starter-template?friend=nuxt" target="_blank"}
观看 Vue School 关于 Nuxt 模块起始模板的视频。
::

#### 如何开发

虽然你的模块源代码位于 `src` 目录内，但大多数场景中，开发模块时你需要一个 Nuxt 应用。这就是 `playground` 目录的用途。它是一个已配置好可以搭配你的模块一起运行的 Nuxt 应用，方便你调试。

你可以像使用任何 Nuxt 应用一样使用 playground。

- 通过 `npm run dev` 启动开发服务器，当你更改 `src` 目录下的模块时，服务器会自动重载
- 通过 `npm run dev:build` 构建 playground

::note
所有其他 `nuxt` 命令都可以针对 `playground` 目录使用（例如 `nuxt <COMMAND> playground`）。你也可以在 `package.json` 中自定义其他 `dev:*` 脚本来调用它们，方便使用。
::

#### 如何测试

模块起始模板附带了基础的测试套件：

- 使用 [ESLint](https://eslint.org) 进行代码检查，命令：`npm run lint`
- 使用 [Vitest](https://vitest.dev) 进行测试运行，命令：`npm run test` 或 `npm run test:watch`

::tip
你可以根据需要扩展默认的测试策略以适应你的需求。
::

#### 如何构建

Nuxt 模块自带由 [`@nuxt/module-builder`](https://github.com/nuxt/module-builder#readme) 提供的构建工具。该构建器无需你配置，支持 TypeScript，确保你的资源能够正确打包并分发至其他 Nuxt 应用。

你可以运行 `npm run prepack` 来构建你的模块。

::tip
虽然某些情况下构建模块很有用，但大多数时候你不需要自己构建：开发时 playground 会帮你处理，发布时也有发布脚本协助。
::

#### 如何发布

::important
在发布模块到 npm 之前，确保你有一个 [npmjs.com](https://www.npmjs.com) 账户，并已通过 `npm login` 在本地登录认证。
::

你可以通过提升版本号后使用 `npm publish` 命令发布，但模块起始模板带有一个发布脚本，可以帮助你确保发布一个可用的模块版本到 npm 以及更多操作。

使用发布脚本前，先提交所有更改（建议遵循 [Conventional Commits](https://www.conventionalcommits.org)，以利用自动版本升级和变更日志更新），然后运行 `npm run release`。

发布脚本运行时会：

- 先执行测试套件：
  - 运行代码检查（`npm run lint`）
  - 运行单元测试、集成测试和端到端测试（`npm run test`）
  - 构建模块（`npm run prepack`）
- 如果测试一切正常，继续发布模块：
  - 根据 Conventional Commits 自动提升版本号并生成变更日志
  - 发布模块到 npm（此过程中，模块会再构建一次，确保版本号生效）
  - 将表示新版本的 git 标签推送到远程仓库

::tip
和其他脚本一样，你可以根据需要在 `package.json` 中调整默认的 `release` 脚本。
::

## 模块开发

Nuxt 模块提供了多种强大的 API 和模式，允许它们以各种方式改变 Nuxt 应用。本节教你如何利用它们。

### 模块结构

我们可以区分两种 Nuxt 模块：

- 已发布的模块，通过 npm 发布 —— 你可以在 [Nuxt 官方网站](/modules) 查看部分社区模块列表。
- “本地”模块，存在于 Nuxt 项目内，可能[内嵌在 Nuxt 配置中](/docs/api/nuxt-config#modules)或作为[ `modules` 目录](/docs/guide/directory-structure/modules)的一部分。

无论哪种，结构都很相似。

#### 模块定义

::note
使用起始模板时，你的模块定义位于 `src/module.ts`。
::

模块定义是你的模块入口。Nuxt 在配置中引用模块时会加载它。

底层而言，Nuxt 模块定义是一个简单（可能是异步）的函数，接收内联选项和一个 `nuxt` 对象，用于与 Nuxt 交互。

```ts
export default function (inlineOptions, nuxt) {
  // 你可以自由操作...
  console.log(inlineOptions.token) // `123`
  console.log(nuxt.options.dev) // `true` 或 `false`
  nuxt.hook('ready', async nuxt => {
    console.log('Nuxt 已准备好')
  })
}
```

你可以使用 [Nuxt Kit](/docs/guide/going-further/kit) 提供的更高级的 `defineNuxtModule` 辅助函数，获得类型提示支持。

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule((options, nuxt) => {
  nuxt.hook('pages:extend', pages => {
    console.log(`发现了 ${pages.length} 个页面`)
  })
})
```

但**我们不推荐**使用底层的函数定义。定义模块时，**推荐**使用带有 `meta` 属性的对象语法，尤其是要发布到 npm 时。

该辅助函数通过实现大量模块常用模式，使定义 Nuxt 模块更简单，保证未来兼容性，提升模块作者和用户体验。

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    // 通常是你的模块在 npm 的包名
    name: '@nuxtjs/example',
    // `nuxt.config` 中持有模块选项的字段名
    configKey: 'sample',
    // 兼容性约束
    compatibility: {
      // 支持的 nuxt 版本范围，遵循 Semver 规范
      nuxt: '>=3.0.0'
    }
  },
  // 模块的默认配置选项，也可以是返回选项的函数
  defaults: {},
  // 简捷注册 Nuxt 钩子
  hooks: {},
  // 其他模块依赖配置——这并不保证依赖模块先于你的模块运行
  // 但允许你在依赖模块运行前修改其配置
  moduleDependencies: {
    'some-module': {
      // 依赖模块的版本约束。如果版本不符，Nuxt 启动时会报错。
      version: '>=2',
      // 默认情况下，除非 optional 被设置，否则会安装列出的依赖模块。
      optional: true,
      // 用于覆盖 `nuxt.options` 中的配置
      overrides: {},
      // 用于设置的默认配置，会覆盖依赖模块默认值，但不会覆盖用户 `nuxt.options` 配置
      defaults: {}
    }
  },
  // 模块逻辑主体，支持异步
  setup(moduleOptions, nuxt) {
    // ...
  }
})
```

最终，`defineNuxtModule` 返回一个带有低级 `(inlineOptions, nuxt)` 签名的包装函数。此函数会处理默认配置等步骤后调用你的 `setup`：

- 支持 `defaults` 与 `meta.configKey` 自动合并模块选项
- 类型提示和自动类型推断
- 提供基本 Nuxt 2 兼容的垫片
- 确保模块只安装一次，使用 `meta.name` 或 `meta.configKey` 生成唯一键
- 自动注册 Nuxt 钩子
- 自动检查兼容性问题（基于模块元信息）
- 为 Nuxt 内部使用暴露 `getOptions` 和 `getMeta`
- 确保只要使用最新 `@nuxt/kit` 的 `defineNuxtModule`，模块保持向后和向前兼容
- 集成模块构建工具链

#### 运行时目录

::note
使用起始模板时，运行时目录位于 `src/runtime`。
::

模块和 Nuxt 配置中的其它内容不会包含在应用运行时，但你可能希望模块提供运行时代码或注入代码到应用中，这就是运行时目录的作用。

在运行时目录内，你可以提供与 Nuxt 应用相关的任意资源：
- Vue 组件
- 组合式函数（composables）
- [Nuxt 插件](/docs/guide/directory-structure/plugins)

对 [服务器引擎](/docs/guide/concepts/server-engine) Nitro 提供：
- API 路由
- 中间件
- Nitro 插件

或者任何你想注入用户 Nuxt 应用的资源：
- 样式表
- 3D 模型
- 图片
- 等等

然后，你可以从你的[模块定义](#模块定义)中注入这些资源。

::tip
了解更多关于资源注入内容，请参阅[示例章节](#recipes)。
::

::warning
已发布的模块不能利用运行时目录内资源的自动导入机制。它们必须从 `#imports` 等位置显式导入。  
原因是性能考虑，自动导入不会应用到位于 `node_modules`（即已发布模块所在）内的文件。
::

### 工具链

模块配备了一套官方工具，帮助你进行开发。

#### `@nuxt/module-builder`

[Nuxt 模块构建器](https://github.com/nuxt/module-builder#readme) 是零配置构建工具，承担了构建和打包模块的繁重工作，确保模块构建产物与 Nuxt 应用的兼容。

#### `@nuxt/kit`

[Nuxt Kit](/docs/guide/going-further/kit) 提供组合式实用工具，帮助模块与 Nuxt 应用交互。推荐尽可能使用 Nuxt Kit 而非手动替代方案，以保证更好的兼容性和代码可读性。

:read-more{to="/docs/guide/going-further/kit"}

#### `@nuxt/test-utils`

[Nuxt 测试工具](/docs/getting-started/testing) 包含一系列实用工具，帮助你在模块测试中设置和运行 Nuxt 应用。

### 示例

这里展示了编写模块时使用的常见模式。

#### 修改 Nuxt 配置

模块可以读取并修改 Nuxt 配置。示例如下，启用一个实验性功能：

```js
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 如果尚未存在，创建 `experimental` 对象
    nuxt.options.experimental ||= {}
    nuxt.options.experimental.componentIslands = true
  }
})
```

当需要处理更复杂的配置修改时，建议使用 [defu](https://github.com/unjs/defu)。

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/extending-and-altering-nuxt-configuration-and-options?friend=nuxt" target="_blank"}
观看 Vue School 关于修改 Nuxt 配置的视频。
::

#### 将选项暴露到运行时

因为模块不属于应用运行时，它们的选项也不会自动包含在内。但在许多情况下，你可能需要在运行时代码中访问某些模块选项。推荐使用 Nuxt 的 [`runtimeConfig`](/docs/api/nuxt-config#runtimeconfig) 来暴露需要的配置。

<!-- TODO: Update after #18466 (or equivalent) -->

```js
import { defineNuxtModule } from '@nuxt/kit'
import { defu } from 'defu'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.options.runtimeConfig.public.myModule = defu(nuxt.options.runtimeConfig.public.myModule, {
      foo: options.foo
    })
  }
})
```

注意此处使用 [`defu`](https://github.com/unjs/defu) 来扩展用户提供的公共运行时配置，而非覆盖。

然后你可以在插件、组件或应用中像使用其他运行时配置一样访问模块选项：

```js
const options = useRuntimeConfig().public.myModule
```

::warning
请谨慎避免在公共运行时配置中暴露敏感配置信息，如私有 API 密钥，因为它们会被打包进公共代码。
::

:read-more{to="/docs/guide/going-further/runtime-config"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/passing-and-exposing-module-options?friend=nuxt" target="_blank"}
观看 Vue School 关于传递和暴露 Nuxt 模块选项的视频。
::

#### 使用 `addPlugin` 注入插件

插件是模块添加运行时逻辑的常用方式。你可以用 `addPlugin` 辅助来注册插件。

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 创建解析器处理相对路径
    const resolver = createResolver(import.meta.url)

    addPlugin(resolver.resolve('./runtime/plugin'))
  }
})
```

:read-more{to="/docs/guide/going-further/kit"}

#### 使用 `addComponent` 注入 Vue 组件

如果模块需要提供 Vue 组件，你可以用 `addComponent` 将它们注册为 Nuxt 的自动导入组件。

```js
import { defineNuxtModule, addComponent } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // 从运行时目录导入组件
    addComponent({
      name: 'MySuperComponent', // 组件在 Vue 模板中的名称
      export: 'MySuperComponent', // （可选）如果是具名导出
      filePath: resolver.resolve('runtime/components/MySuperComponent.vue')
    })

    // 从第三方库导入组件
    addComponent({
      name: 'MyAwesomeComponent', 
      export: 'MyAwesomeComponent', 
      filePath: '@vue/awesome-components'
    })
  }
})
```

或者，你可以使用 `addComponentsDir` 一次性添加整个目录：

```ts
import { defineNuxtModule, addComponentsDir } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addComponentsDir({
      path: resolver.resolve('runtime/components')
    })
  }
})
```

#### 使用 `addImports` 和 `addImportsDir` 注入组合式函数（composables）

如果模块需要提供组合式函数，可以用 `addImports` 来添加自动导入。

```ts
import { defineNuxtModule, addImports, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImports({
      name: 'useComposable', // 组合函数名称
      as: 'useComposable',
      from: resolver.resolve('runtime/composables/useComposable') // 组合函数路径
    })
  }
})
```

也可使用 `addImportsDir` 添加整个目录：

```ts
import { defineNuxtModule, addImportsDir, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addImportsDir(resolver.resolve('runtime/composables'))
  }
})
```

#### 使用 `addServerHandler` 注入服务器路由

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello',
      handler: resolver.resolve('./runtime/server/api/hello/index.get')
    })
  }
})
```

还可以添加动态服务器路由：

```ts
import { defineNuxtModule, addServerHandler, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)

    addServerHandler({
      route: '/api/hello/:name',
      handler: resolver.resolve('./runtime/server/api/hello/[name].get')
    })
  }
})
```

#### 注入其他类型资源

如果模块需要注入其它资源，也可以如此进行。示例如下，模块通过 Nuxt 的 `css` 数组注入样式表：

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.options.css.push(resolver.resolve('./runtime/style.css'))
  }
})
```

一个更高级的示例，模块通过 [Nitro](/docs/guide/concepts/server-engine) 的 `publicAssets` 选项暴露一整目录资源：

```js
import { defineNuxtModule, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    nuxt.hook('nitro:config', async (nitroConfig) => {
      nitroConfig.publicAssets ||= []
      nitroConfig.publicAssets.push({
        dir: resolver.resolve('./runtime/public'),
        maxAge: 60 * 60 * 24 * 365 // 一年
      })
    })
  }
})
```

#### 在你的模块中使用其它模块

模块如需依赖其他模块，可使用 Nuxt Kit 的 `installModule` 功能。举例，如果你想在模块中使用 Nuxt Tailwind：

```ts
import { defineNuxtModule, createResolver, installModule } from '@nuxt/kit'

export default defineNuxtModule<ModuleOptions>({
  async setup (options, nuxt) {
    const resolver = createResolver(import.meta.url)

    // 注入包含 Tailwind 指令的 CSS 文件
    nuxt.options.css.push(resolver.resolve('./runtime/assets/styles.css'))

    await installModule('@nuxtjs/tailwindcss', {
      // 模块配置
      exposeConfig: true,
      config: {
        darkMode: 'class',
        content: {
          files: [
            resolver.resolve('./runtime/components/**/*.{vue,mjs,ts}'),
            resolver.resolve('./runtime/*.{mjs,js,ts}')
          ]
        }
      }
    })
  }
})
```

#### 使用钩子

[生命周期钩子](/docs/guide/going-further/hooks) 允许你扩展 Nuxt 的几乎所有方面。模块可通过定义钩子映射或编程调用方式注册。

```js
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  // 通过 hooks 映射注册 `app:error` 钩子
  hooks: {
    'app:error': (err) => {
      console.info(`捕获错误：${err}`);
    }
  },
  setup (options, nuxt) {
    // 编程方式注册 `pages:extend` 钩子
    nuxt.hook('pages:extend', (pages) => {
      console.info(`发现了 ${pages.length} 个页面`);
    })
  }
})
```

:read-more{to="/docs/api/advanced/hooks"}

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/nuxt-lifecycle-hooks?friend=nuxt" target="_blank"}
观看 Vue School 关于在模块中使用 Nuxt 生命周期钩子的视频。
::

::note
**模块清理**  
如果你的模块开启、处理或启动监听器，应该在 Nuxt 生命周期结束时关闭它们。可以使用 `close` 钩子。

```ts
import { defineNuxtModule } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    nuxt.hook('close', async nuxt => {
      // 你的自定义清理代码
    })
  }
})
```
::

##### 自定义钩子

模块也能定义并调用自己的钩子，这是一种强大模式，可以让你的模块更具扩展性。

如果你期望其它模块订阅你的钩子，应在 `modules:done` 钩子中调用它们，确保所有模块均已完成设置并注册监听。

```ts
// my-module/module.ts
import { defineNuxtModule } from '@nuxt/kit'

export interface ModuleHooks {
  'my-module:custom-hook': (payload: { foo: string }) => void
}

export default defineNuxtModule({
  setup (options, nuxt) {
    // 在 modules:done 中调用钩子
    nuxt.hook('modules:done', async () => {
      const payload = { foo: 'bar' }
      await nuxt.callHook('my-module:custom-hook', payload)
    })
  }
})
```

#### 添加模板/虚拟文件

如果你需要添加虚拟文件，供用户项目中导入，可用 `addTemplate` 工具。

```ts
import { defineNuxtModule, addTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 文件会加入 Nuxt 内部虚拟文件系统，可通过 '#build/my-module-feature.mjs' 导入
    addTemplate({
      filename: 'my-module-feature.mjs',
      getContents: () => 'export const myModuleFeature = () => "hello world !"'
    })
  }
})
```

服务端应使用 `addServerTemplate`。

```ts
import { defineNuxtModule, addServerTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    // 文件加入 Nitro 虚拟文件系统，可在服务器代码中通过 'my-server-module.mjs' 导入
    addServerTemplate({
      filename: 'my-server-module.mjs',
      getContents: () => 'export const myServerModule = () => "hello world !"'
    })
  }
})
```

#### 添加类型声明

你可能想给用户项目添加类型声明（比如扩展 Nuxt 接口或定义全局类型）。Nuxt 提供了 `addTypeTemplate` 辅助，写入模板到磁盘并在生成的 `nuxt.d.ts` 中添加引用。

如果模块需扩展 Nuxt 管理的类型，可用 `addTypeTemplate` 实现：

```js
import { defineNuxtModule, addTemplate, addTypeTemplate } from '@nuxt/kit'

export default defineNuxtModule({
  setup (options, nuxt) {
    addTypeTemplate({
      filename: 'types/my-module.d.ts',
      getContents: () => `// 由 my-module 生成
        interface MyModuleNitroRules {
          myModule?: { foo: 'bar' }
        }
        declare module 'nitropack/types' {
          interface NitroRouteRules extends MyModuleNitroRules {}
          interface NitroRouteConfig extends MyModuleNitroRules {}
        }
        export {}`
    })
  }
})
```

若需更细粒度控制，可使用 `prepare:types` 钩子，注册回调注入类型：

```ts
const template = addTemplate({ /* 模板选项 */ })
nuxt.hook('prepare:types', ({ references }) => {
  references.push({ path: template.dst })
})
```

##### 更新模板

如果需要更新模板/虚拟文件，可以用 `updateTemplates`：

```ts
nuxt.hook('builder:watch', async (event, path) => {
  if (path.includes('my-module-feature.config')) {
    // 重新加载已注册的模板
    updateTemplates({ filter: t => t.filename === 'my-module-feature.mjs' })
  }
})
```

### 测试

测试帮助保证模块在各种配置下的预期工作。以下内容讲述如何对模块做各种测试。

#### 单元测试及集成测试

::tip
我们仍在讨论和探索如何简化 Nuxt 模块的单元及集成测试。  
:br :br  
[查看此 RFC 参与讨论](https://github.com/nuxt/nuxt/discussions/18399)。
::

#### 端到端测试

[Nuxt 测试工具](/docs/getting-started/testing) 是帮助模块进行端到端测试的首选库。流程如下：

1. 在 `test/fixtures/*` 内创建用于测试的 Nuxt 应用“夹具”（fixture）
2. 在测试文件中使用夹具搭建 Nuxt
3. 用 `@nuxt/test-utils` 提供的工具与夹具交互（如请求页面）
4. 对夹具执行断言（如“HTML 包含…”）
5. 重复上述过程

示例夹具：

```js [test/fixtures/ssr/nuxt.config.ts]
// 1. 创建用于测试的 Nuxt 应用
import MyModule from '../../../src/module'

export default defineNuxtConfig({
  ssr: true,
  modules: [
    MyModule
  ]
})
```

及对应测试：

```js [test/rendering.ts]
import { describe, it, expect } from 'vitest'
import { fileURLToPath } from 'node:url'
import { setup, $fetch } from '@nuxt/test-utils/e2e'

describe('ssr', async () => {
  // 2. 在测试文件中搭建 Nuxt 应用
  await setup({
    rootDir: fileURLToPath(new URL('./fixtures/ssr', import.meta.url)),
  })

  it('渲染首页', async () => {
    // 3. 调用测试工具与夹具交互
    const html = await $fetch('/')

    // 4. 断言结果
    expect(html).toContain('<div>ssr</div>')
  })
})

// 5. 可继续添加更多测试用例
describe('csr', async () => { /* ... */ })
```

::tip
此流程的示例可见于[模块起始模板](https://github.com/nuxt/starter/blob/module/test/basic.test.ts)。
::

#### 使用 Playground 和外部项目进行手动测试

拥有一个 playground Nuxt 应用进行模块开发时的测试非常有用。[模块起始模板已集成该功能](#如何开发)。

你也可以在本地用其它 Nuxt 应用（非模块仓库内）测试模块。使用 [`npm pack`](https://docs.npmjs.com/cli/commands/npm-pack)（或相应包管理器命令）生成 tar 包，随后在测试项目的 `package.json` 中以 `"my-module": "file:/path/to/tarball.tgz"` 引入。之后即可像常规模块一样使用。

### 最佳实践

强大的功能伴随责任。模块虽强大，但请遵守以下最佳实践，确保应用性能和良好开发者体验。

#### 模块应异步

前文提到，Nuxt 模块可以异步实现。例如，可能需要调用一些异步 API 或函数。

但要注意，Nuxt 会等待模块完成设置后才继续处理下一个模块、启动开发服务器、进行构建等操作。建议将耗时逻辑延迟到 Nuxt 钩子中完成。

::warning
如果模块设置时间超过 **1 秒**，Nuxt 会发出警告。
::

#### 公开接口应添加前缀

模块应对任何公开的配置、插件、API、组合函数或组件添加明显前缀，避免与其它模块或内部冲突。

理想做法是用模块名作为前缀（例如模块名为 `nuxt-foo`，则导出 `<FooButton>` 组件与 `useFooBar()` 而非 `<Button>` 和 `useBar()`）。

#### 使用生命周期钩子做一次性初始化

模块若需执行一次性初始化（例如生成配置文件、设置数据库、安装依赖等），应使用生命周期钩子，而非放在主 `setup` 函数。

```ts
import { addServerHandler, defineNuxtModule } from 'nuxt/kit'
import semver from 'semver'

export default defineNuxtModule({
  meta: {
    name: 'my-database-module',
    version: '1.0.0',
  },
  async onInstall (nuxt) {
    // 一次性初始化：创建数据库模式、生成配置文件等
    await generateDatabaseConfig(nuxt.options.rootDir)
  },
  async onUpgrade (options, nuxt, previousVersion) {
    // 版本迁移
    if (semver.lt(previousVersion, '1.0.0')) {
      await migrateLegacyData()
    }
  },
  setup (options, nuxt) {
    // 常规构建逻辑，每次构建执行
    addServerHandler({ /* ... */ })
  },
})
```

该模式避免每次构建重复工作，提升开发体验。详见 [生命周期钩子文档](/docs/api/kit/modules#using-lifecycle-hooks-for-module-installation-and-upgrade)。

#### 友好支持 TypeScript

Nuxt 对 TypeScript 有一流支持，保证最佳开发体验。

暴露类型并用 TypeScript 开发模块，可为用户带来便利，即使非 TS 用户也受益。

#### 避免使用 CommonJS 语法

Nuxt 基于原生 ESM。请阅读 [原生 ES 模块](/docs/guide/concepts/esm) 了解更多。

#### 撰写模块使用文档

建议在 README 中详细说明：

- 为什么使用此模块？
- 如何使用此模块？
- 模块具体功能是什么？

同时链接至集成网站和文档会更好。

#### 提供 StackBlitz 示例或起始模板

最好有一个最简示例项目，通过 [StackBlitz](https://nuxt.new/s/v4) 集成并链接到模块 README。

这不仅为潜在用户提供快速上手通道，也方便用户制作最小复现送修。

#### 不同版本不要宣传绑定

Nuxt、Nuxt Kit 和其他工具链致力于向上和向下兼容。

请用 “X for Nuxt” 而非 “X for Nuxt 3” 避免生态系统割裂，版本限制应通过 `meta.compatibility` 设置。

#### 遵守起始模板默认

模块起始模板带有默认工具及配置（如 ESLint 配置）。若计划开源，沿用这些默认保证模块风格和其他[社区模块](/modules)一致，方便别人贡献。

## 生态系统

[Nuxt 模块生态](/modules) 每月下载超 1500 万次，提供丰富功能和各种工具的集成。你也能参与其中！

::tip{icon="i-lucide-video" to="https://vueschool.io/lessons/exploring-nuxt-modules-ecosystem-and-module-types?friend=nuxt" target="_blank"}
观看 Vue School 关于 Nuxt 模块类型的视频。
::

### 模块类型

**官方模块** 是以 `@nuxt/` 命名空间发布的模块（例如 [`@nuxt/content`](https://content.nuxtjs.org)），由 Nuxt 团队开发维护。社区欢迎贡献，使其更强大！

**社区模块** 是以 `@nuxtjs/` 命名空间发布的模块（例如 [`@nuxtjs/tailwindcss`](https://tailwindcss.nuxtjs.org)），由社区成员维护，同样欢迎贡献。

**第三方及其他社区模块** 通常前缀为 `nuxt-`，任何人均可发布。使用此前缀方便在 npm 上被搜索到，是尝试新想法的好起点！

**私有或个人模块** 是为自己或公司定制的模块，无需遵循任何命名规则，通常在 npm 组织范围内（如 `@my-company/nuxt-auth`）。

### 列出你的社区模块

任何社区模块均欢迎在[模块列表](/modules)中被收录。申请收录请在 [nuxt/modules 仓库](https://github.com/nuxt/modules/issues/new?template=module_request.yml)中开 Issue。Nuxt 团队将协助你应用最佳实践。

### 加入 `nuxt-modules` 和 `@nuxtjs/`

将模块迁移到 [nuxt-modules](https://github.com/nuxt-modules) 意味着随时有人协助，也能联合力量打造完美解决方案。

如果你已有发布且正常工作的模块，想将其转入 `nuxt-modules`，请[在 nuxt/modules 提交 Issue](https://github.com/nuxt/modules/issues/new)。

加入 `nuxt-modules` 后，我们可将你的社区模块重命名为 `@nuxtjs/` 范围包，并为其文档提供子域（例如 `my-module.nuxtjs.org`）。

<!-- ## 模块内部机制

或许可以简要介绍模块底层工作原理、优先级等 -->